# **Домашнее задание по теме «JVM. Организация памяти, сборщики мусора, VisualVM»**

## **Задача 1 (обязательная)**

Просмотрите код ниже и опишите (текстово или с картинками) каждую строку с точки зрения происходящего в JVM.

Не забудьте упомянуть про:

* ClassLoader’ы;

* области памяти (стэк (и его фреймы), heap);
* сборщик мусора.

**Код для исследования**

```java
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```

Ответ оформите в виде README.md в публичном гитрепо. На проверку скиньте ссылку на этот README.md в вашем репозитории.

## **Решение**

Загрузка классов происходит до выполнения кода. Осуществляется с помощью встроенных классов-загрузчиков.

**Организация памяти и сборка мусора**

В начале выполнения метода main() в стеке (на самом его дне) будет выделено пространство для хранения примитивов и ссылок этого метода. Это пространство будет называться фрейм main().


**1.  int i = 1;**

Инициализируем переменную i. Это примитивный тип данных, вся информация (имя переменной и значение) будет храниться в стеке.

**2.  Object o = new Object();**

Создаем новый объект класса Object. Ссылка **o** будет храниться в стеке(фрейм main), а само значение объекта - в куче(heap).

**3.  Integer ii = 2;**  

Создаем новый объект класса Integer. Ссылка ii будет храниться в стеке(фрейм main), а само значение объекта - 2 - в куче.

**4.  printAll(o, i, ii);**

Для вызова метода  printAll() в стеке будет создан новый блок памяти (графически он был бы изображен выше предыдущего). Он будет называться фрейм printAll(), хранить примитивное значение i, а также ссылки **o** и **ii**. Сами же объекты(их значения) так и останутся лежать в куче.


**5.  Integer uselessVar = 700;** 

Создаем новый объект класса Integer. Ссылку uselessVar кладем в стек (фрейм printAll), а значение - 700 - в кучу.
Данный объект не будет использоваться в методе printAll() и за пределы этого метода он тем более не выйдет, поэтому при запуске сборщика мусора его значение может быть удалено из кучи.

**6.  System.out.println(o.toString() + i + ii);** 

На этом этапе в стеке будет создан новый фрейм - println(). Он будет хранить примитивное значение i, а также ссылку ii на объект в куче. Кроме того будет создан новый фрейм toString(), он будет содержать ссылки на строки, получившиеся в результате выполнения o.toString(), а также в результате String.valueOf(i) и String.valueOf(ii). Данные строки будут сохранены в пуле строк. Пул строк находится в куче. В пуле строк также будет сохранен результат конкатенации строк o.toString(), i и ii, ссылка на эту строку будет сохранена во фрейме println().
После завершения метода printAll() из стека будут удалены фреймы toString(), println() и сам фрейм printAll(). А из пула строк сборщиком мусора могут быть удалены строки, появившиеся в нем после вызова метода printAll().

**7.  System.out.println("finished");** 

Здесь будет создан новый фрейм с названием println(), в нем будет ссылка на строку из пула строк со значением "finished". После завершения метода фрейм println() будет удален. Если бы программа продолжалась, то строка "finished" могла бы быть удалена из пула строк сборщиком мусора. 
По завершении работы программы будет удален фрейм main().
